---
/**
 * Section Component â€“ Order of Importance for Heading and Description Values:
 *
 * 1. **Section Override:**
 *    - Use the values passed directly via the Section props (i.e. the "heading" and "description" props).
 *
 * 2. **Meta Values:**
 *    - If no direct override is provided, load the collection meta file (_meta.mdx, _meta.md, or _meta.json)
 *      and use the "heading" and "description" defined there.
 *
 * 3. **Auto-Fallback:**
 *    - If neither the Section props nor the meta file provide a value, automatically generate a default.
 *      For the heading, this fallback is the collection slug capitalized (e.g., "services" becomes "Services").
 *
 * This hierarchy ensures that the highest priority values are used where explicitly provided,
 * while sensible defaults are always available.
 */

import Heading from "./Heading.jsx";
import Button from "./Button.jsx";
import ItemsTemplate from "./ItemsTemplate.astro";
import {
  resolveMetaProps,
  resolveHeading,
  resolveDescription,
  resolveButtonsArray,
  getSectionItems,
} from "@/utils/SectionUtils";
import { capitalize } from "@/utils/ContentUtils";
import { componentMapping } from "@/utils/ComponentMapping"; // Import mapping

const {
  collection: collectionName,
  query: queryType,
  component: ItemComponent, // explicit component prop from the page
  heading,
  description,
  buttons,
  buttonsSectionClass,
  sectionClass,
  itemsClass,
  itemClass,
  contentClass,
  ...props
} = Astro.props;

const meta = await resolveMetaProps(collectionName, queryType);

// Extract default section settings from meta (if defined)
const defaultSection = meta.defaultSection || {};

// Merge defaults with any explicit overrides
const finalSectionClass = sectionClass || defaultSection.sectionClass || "";
const finalContentClass = contentClass || defaultSection.contentClass || "";
const finalItemsClass = itemsClass || defaultSection.itemsClass || "";
const finalButtonsSectionClass = buttonsSectionClass || defaultSection.buttonsSectionClass || "";

// Determine the component to render:
// Priority: explicit prop > defaultSection.component (from meta)
let finalComponent = ItemComponent || defaultSection.component;

// If the final component is provided as a string, map it to the actual component.
if (typeof finalComponent === "string") {
  finalComponent = componentMapping[finalComponent] || componentMapping["Card"];
}

let items = [];
const isDynamic = Boolean(collectionName && queryType);
if (isDynamic) {
  items = await getSectionItems(queryType, collectionName, Astro.url.pathname);
  if (items.length === 0) return;
}

const buttonsArray = resolveButtonsArray(
  buttons,
  meta.hasPage,
  collectionName,
  Astro.url.pathname
);
const itemsDefaultHasPage = meta.itemsHasPage ?? false;
---

{isDynamic ? (
  <section
    class={`${finalSectionClass} w-full py-[var(--spacing-lg)] lg:px-[var(--spacing-md)]`}
    data-collection={collectionName}
    {...props}
  >
    <div class={`${finalContentClass} w-3/4 my-[var(--spacing-lg)]`}>
      {resolveHeading(heading, meta.heading, collectionName).map((head, i) => {
        const headObj = typeof head === "string" ? { text: head } : head;
        const tagName = headObj.tagName || "h2";
        return (
          <Heading key={i} tagName={tagName} className={headObj.class || ""}>
            {headObj.text}
          </Heading>
        );
      })}
      <slot name="aboveItemsInjection" />
      <ItemsTemplate
        items={items}
        collection={collectionName}
        query={queryType}
        itemsClass={finalItemsClass}
        itemClass={itemClass}
        ItemComponent={finalComponent}  {/* Use our mapped component */}
        HasPage={itemsDefaultHasPage}
        pathname={Astro.url.pathname}
      />
      <slot name="belowItemsInjection" />
      <div class={finalButtonsSectionClass}>
        {buttonsArray.length > 0 &&
          buttonsArray.map((btn, index) => {
            const btnDefaults = {
              text: capitalize(collectionName),
              link: `/${collectionName}`,
              class: "",
              variant: "primary",
            };
            const finalButtonProps = { ...btnDefaults, ...btn };
            return (
              <Button
                key={index}
                href={finalButtonProps.link}
                className={finalButtonProps.class}
                ariaLabel={finalButtonProps.text}
                variant={finalButtonProps.variant}
              >
                {finalButtonProps.text}
              </Button>
            );
          })}
      </div>
      <slot />
    </div>
  </section>
) : (
  <section
    class={`${finalSectionClass} w-full lg:px-[var(--spacing-md)]`}
    {...props}
  >
    <div class={`${finalContentClass} w-3/4`}>
      {resolveHeading(heading, meta.heading, collectionName).map((head, i) => {
        const headObj = typeof head === "string" ? { text: head } : head;
        const tagName = headObj.tagName || "h2";
        return (
          <Heading key={i} tagName={tagName} className={headObj.class || ""}>
            {headObj.text}
          </Heading>
        );
      })}
      {resolveDescription(description, meta.description) && (
        <p class={description?.class}>
          {resolveDescription(description, meta.description)}
        </p>
      )}
      <slot />
      <div class={finalButtonsSectionClass}>
        {buttonsArray.length > 0 &&
          buttonsArray.map((btn, index) => {
            const btnDefaults = {
              text: capitalize(collectionName),
              link: `/${collectionName}`,
              class: "",
            };
            const finalButtonProps = { ...btnDefaults, ...btn };
            return (
              <Button
                key={index}
                href={finalButtonProps.link}
                className={finalButtonProps.class}
                ariaLabel={finalButtonProps.text}
                variant={finalButtonProps.variant}
              >
                {finalButtonProps.text}
              </Button>
            );
          })}
      </div>
    </div>
  </section>
)}
